{"componentChunkName":"component---src-templates-blog-template-js","path":"/CS공부/브라우저 렌더링/","result":{"data":{"cur":{"id":"c602ddec-0bea-5709-8288-1f238b3d7fde","html":"<h1 id=\"브라우저-구성요소\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C\" aria-label=\"브라우저 구성요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 구성요소</h1>\n<hr>\n<ul>\n<li>사용자 인터페이스: 주소표시줄, 이전/다음 버튼, 홈버튼, 새로고침 등 요청한 페이지를 보여주는 창 외에 사용자가 컨트롤할 수 있는 부분.</li>\n<li>브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이에 동작을 제어한다. ex) 전달자 역할, 자료 저장소에서 자료를 찾는 역할</li>\n<li>자료 저장소: 쿠키 등의 자료를 컴퓨터 하드디스크에 저장한다. (HTML5부터 Web Database에 저장 가능)</li>\n<li>렌더링 엔진: 요청한 URI를 브라우저 엔진에게 받아서 server에게 요청한다.(통신) server로부터 URI에 해당하는 데이터(HTML, CSS, JavaScript)를 받아서 파싱한 후 렌더링한다.(chrome webkit)</li>\n<li>통신: 렌더링 엔진으로부터 HTTP 요청 등을 받아서 네트워크 처리 후 응답을 전달한다.</li>\n<li>자바스크립트 해석기: Javascript를 파싱한다(chrome V8)</li>\n<li>UI 백엔드: 렌더트리를 브라우저에 그리는 역할을 담당한다.</li>\n</ul>\n<h1 id=\"브라우저-렌더링-과정각-요소의-특징\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EA%B0%81-%EC%9A%94%EC%86%8C%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"브라우저 렌더링 과정각 요소의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 렌더링 과정(각 요소의 특징)</h1>\n<hr>\n<ol>\n<li>사용자가 사용자 인터페이스에 주소표시줄에 URI를 입력하여 브라우저 엔진에 전달한다.</li>\n<li>브라우저 엔진은 자료 저장소에서 URI에 해당하는 자료를 찾고, 해당 자료를 쿠키에 저장했다면 그 자료를 렌더링 엔진에 전달한다.</li>\n<li>렌더링 엔진은 브라우저 엔진에서 가져온 자료를 분석한다. 동시에 URI 데이터를 통신, 자바스크립트 해석기, UI 백엔드로 전파한다.</li>\n<li>또한 렌더링 엔진은 통신 레이어에 URI에 대한 추가 데이터가 있다면 요청하고 응답할 때까지 기다린다.</li>\n<li>응답받은 데이터에서 HTML, CSS는 렌더링 엔진에 파싱한다.</li>\n<li>응답받은 데이터에서 Javascript는 JavaScript 해석기가 파싱한다.</li>\n<li>JavaScript 해석기는 파싱한 결과를 렌더링 엔진에 전달하여 3번과 5번에서 파싱한 HTML의 결과인 DOM tree를 조작한다.</li>\n<li>조작이 완료되면 DOM node(DOM tree 구성요소)는 render object(렌더트리 구성요소)로 변한다.</li>\n<li>UI 백엔드는 render object를 브라우저 렌더링 화면에 띄워준다.</li>\n</ol>\n<h1 id=\"렌더링-엔진\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%94%EC%A7%84\" aria-label=\"렌더링 엔진 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 엔진</h1>\n<hr>\n<p>렌더링 엔진은 URI를 통해 요청을 받아서 해당하는 데이터를 렌더링하는 역할을 담당한다.<br>\nchrome과 IOS는 webkit이라는 렌더링 엔진을 사용한다.</p>\n<h3 id=\"렌더링-엔진-동작-과정\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%94%EC%A7%84-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"렌더링 엔진 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 엔진 동작 과정</h3>\n<p><code class=\"language-text\">DOM tree 구축을 위한 HTML 파싱 => 렌더트리 구축 => 렌더트리 배치 => 렌더트리 그리기</code></p>\n<ol>\n<li><code class=\"language-text\">DOM tree 구축</code>을 위한 HTML, CSS, Javscript 파싱: HTML 문서를 파싱한 후, content tree 내부에서 tag를 DOM node로 변환한다.\n그 다은 CSS 파일과 함께 모든 스타일 요소를 파싱한다. 스타일 요소와 HTML 표시 규칙, Javascript의 파싱 결과물은 렌더트리를 생성한다.</li>\n<li><code class=\"language-text\">렌더트리 구축</code>: HTML과 CSS를 파싱해서 만들어진 렌더트리는 색상 또는 면적 등 시각적 속성을 갖는 사각형을 포함한다. 정해진 순서대로 렌더링한다.</li>\n<li><code class=\"language-text\">렌더트리 배치</code>: 렌더트리가 생성이 끝나면, 배치가 시작된다. 각 노트가 정확한 위치에 표시되기 위해 이동한다.</li>\n<li><code class=\"language-text\">렌더트리 그리기</code>: 각 노드 배치를 완료하면 UI 백엔드에서 각 노드를 가로지르며 paint 작업을 한다.</li>\n</ol>\n<p><strong>1번과 2,3,4번은 병렬적으로 진행된다.</strong>\n통신 레이어에서 data를 계속 받아오면서<br>\n받아온 HTML, CSS, JavaScript를 파싱하면서(1번)\n렌더트리에 노드를 그린다.(2,3,4번)</p>\n<h1 id=\"webkit의-동작과정\" style=\"position:relative;\"><a href=\"#webkit%EC%9D%98-%EB%8F%99%EC%9E%91%EA%B3%BC%EC%A0%95\" aria-label=\"webkit의 동작과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>webkit의 동작과정</h1>\n<ol>\n<li>HTML을 파싱하여 DOM 트리를 생성한다.</li>\n</ol>\n<ul>\n<li>왜 HTML을 DOM 트리로 바꾸는가? DOM으로 바꾼 HTML은 JavaScript가 조작할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;html>\n  &lt;body>\n    &lt;span>Hello World&lt;/span>\n    &lt;script>&lt;/script>\n  &lt;/body>\n&lt;/html></code></pre></div>\n<p>브라우저는 tag의 파싱과 실행을 동시에 진행한다.</p>\n<ul>\n<li>왜 <code class=\"language-text\">&lt;script></code>가 body 마지막 줄에 있어야 하나? 앞에 모든 태그들을 파싱한 뒤에 스크립트를 마지막에 파싱하는 동안 추가적으로 파싱할 html태그가 남아있지 않기 때문이다.\n그러므로 HTML5에서 추가된 기능이 있다.</li>\n</ul>\n<ul>\n<li>HTML에서는 <code class=\"language-text\">&lt;script></code> 태그를 비동기로 처리하는 속성을 추가했다.</li>\n</ul>\n<ol start=\"2\">\n<li>CSS를 파싱하여 스타일 규칙을 얻는다.</li>\n<li>DOM 트리를 생성하는 동시에, 이미 생성된 DOM 트리와 스타일 규칙을 Attachment 한다.\n<ul>\n<li>DOM tree를 구성하는 하나의 DOM node는 attach라는 method를 가진다. - 새로운 DOM node가 추가되면 attach가 호출되어 render object를 생성한다.</li>\n<li>render object는 render tree의 구성요소로써, 자신과 자식 요소를 어떻게 배치하고 그려야할지 안다.</li>\n<li>node의 css box를 표시할 정보를 가지고 있다.</li>\n<li>모든 DOM 노드가 전부 render object로 생성되는 것은 아니다. ex) head tag, display none tag 등</li>\n<li><code class=\"language-text\">&lt;html></code>과 <code class=\"language-text\">&lt;body></code> DOM 노드 또한 render object로 구성되는데 이들은 render tree root로써 render view라고 부른다.</li>\n<li>나머지 DOM node들은 render object로 생성되어 이 render tree root에 추가된다.</li>\n</ul>\n</li>\n<li>구축한 렌더 트리를 배치한다.\n배치는 <code class=\"language-text\">&lt;html></code> 요소에 해당하는 최상위 render object에서 시작한다. 화면에 왼쪽 위부터 render object에 해당하는 DOM node를 그려나간다.</li>\n<li>배치가 끝난 렌더 트리를 그린다.</li>\n</ol>\n<h1 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>references</h1>\n<hr>\n<ul>\n<li><a href=\"https://d2.naver.com/helloworld/59361\">https://d2.naver.com/helloworld/59361</a></li>\n<li><a href=\"https://davidhwang.netlify.app/Developments/browser-rendering-process/\">https://davidhwang.netlify.app/Developments/browser-rendering-process/</a></li>\n</ul>","excerpt":"브라우저 구성요소 사용자 인터페이스: 주소표시줄, 이전/다음 버튼, 홈버튼, 새로고침 등 요청한 페이지를 보여주는 창 외에 사용자가 컨트롤할 수 있는 부분. 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이에 동작을 제어한다. ex) 전달자 역할, 자료 저장소에서 자료를 찾는 역할 자료 저장소: 쿠키 등의 자료를 컴퓨터 하드디스크에 저장한다. (HTML5부터 Web Database에 저장 가능) 렌더링 엔진: 요청한 URI를 브라우저 엔진에게 받아서 server에게 요청한다.(통신) server로부터 URI에 해당하는 데이터(HTML, CSS, JavaScript)를 받아서 파싱한 후 렌더링한다.(chrome webkit) 통신: 렌더링 엔진으로부터 HTTP 요청 등을 받아서 네트워크 처리 후 응답을 전달한다. 자바스크립트 해석기: Javascript를 파싱한다(chrome V8) UI 백엔드: 렌더트리를 브라우저에 그리는 역할을 담당한다. 브라우저 렌더링 과정(각 요소의 특징…","frontmatter":{"date":"October 05, 2022","title":"브라우저 렌더링 과정","categories":"CS공부","author":"Steadystudy","emoji":"🔥"},"fields":{"slug":"/CS공부/브라우저 렌더링/"}},"next":null,"prev":{"id":"e3300426-b6c0-50e5-99d1-f235a5f7c459","html":"<h1 id=\"왜-브라우저-렌더링-최적화를-해야하는가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"왜 브라우저 렌더링 최적화를 해야하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 브라우저 렌더링 최적화를 해야하는가?</h1>\n<p>오늘날의 웹 사용자는 페이지가 빠르게 로드되고 잘 실행될 것을 기대한다.<br>\n성능이 뛰어난 사이트와 앱을 만드려면 브라우저에서 HTML, JavaScript 및 CSS를 처리하는 방법을 이해해야 한다.</p>\n<h3 id=\"fpsframe-per-second\" style=\"position:relative;\"><a href=\"#fpsframe-per-second\" aria-label=\"fpsframe per second permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FPS(Frame Per Second)</h3>\n<p>fps는 1초에 몇 프레임이 그려지는지 표현하는 단위이다.<br>\n60fps는 1초에 60장의 프레임이 그려지는 것이다.<br>\n1/60(second) = <strong>16.66ms</strong>안에 새로운 화면을 브라우저가 렌더링을 성공하지 못한다면 애니메이션이 끊김 현상이 발생한다.<br>\n그러나 실제로 브라우저는 하우스키핑 작업을 수행해야 하므로 모든 작업을 <strong>10ms</strong> 이내에 완료해야 한다.</p>\n<h1 id=\"pixel-pipeline\" style=\"position:relative;\"><a href=\"#pixel-pipeline\" aria-label=\"pixel pipeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pixel Pipeline</h1>\n<p><code class=\"language-text\">JS/CSS > Style > Layout > Paint > Composite</code></p>\n<ul>\n<li>Layout: 브라우저에 구성 요소를 배치하는 작업이다. 웹의 레이아웃 모델은 한 요소가 다른 요소에 영향을 줄 수 있다.</li>\n<li>Paint: 픽셀을 채우는 과정이다. 기본적으로 구성 요소의 모든 시각적 부분인 텍스트, 색상, 이미지 등을 그리는 작업이다.</li>\n<li>Composite: 화면에 표시하기 위해 페이지에서 paint 된 부분을 합치는 과정이다.</li>\n</ul>\n<h1 id=\"크롬-브라우저-rendering-path\" style=\"position:relative;\"><a href=\"#%ED%81%AC%EB%A1%AC-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-rendering-path\" aria-label=\"크롬 브라우저 rendering path permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>크롬 브라우저 Rendering Path</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">document.getElementById(\"box\").style.height = \"100px\";</code></pre></div>\n<ol>\n<li><strong>recalculate style</strong>: 엘리먼트에 style을 적용하기 위해 계산하는 작업 (엘리먼트의 style객체가 변경될 떄 발생함)</li>\n<li>height 속성 변경으로 좌표 계산이 필요한가?</li>\n<li>계산이 필요하다면 <strong>Layout</strong> 발생: 언제 발생? width, height, left, top, scroll 등이 변경될 때 발생함.</li>\n<li>효과적인 처리를 위해 <strong>Update Layer Tree</strong>: Layout을 위해, Render Tree를 <strong>변경</strong>하고, paint를 위해 텍스쳐를 <strong>예약</strong>하는 작업</li>\n<li>계산된 영역의 정보를 비트맵으로 저장하기 위해 <strong>paint</strong> 발생: Layer에 엘리먼트의 픽셀 정보를 기록하는 작업</li>\n<li>Composite Layer 작업에서 각 <strong>레이어</strong>를 병합 후, 화면 출력: Layer를 변형하여 화면에 그리는 작업</li>\n</ol>\n<p><code class=\"language-text\">부드러운 애니메이션을 위해서는 위 작업이 모두 10ms 내에 처리되어야 한다.</code></p>\n<p><strong>Layer model</strong>: 웹 페이지를 렌더링하기 위해 필요한 이미지 단위 요소</p>\n<ul>\n<li>레이어들을 배치/합성하여 최종적인 웹페이지를 표현한다.</li>\n<li>모든 페이지는 root 레이어를 가진다.</li>\n<li>레이어의 이미지는 텍스처로서 paint 작업시, CPU에 의해 Video Memory에 로드된다. 따라서, 레이어 생성 비용이 크고, 추가 Memory가 필요하다.</li>\n</ul>\n<h2 id=\"어떤-장치가-연산하여-각-렌더링-프로세스를-수행하는-것일까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A4-%EC%9E%A5%EC%B9%98%EA%B0%80-%EC%97%B0%EC%82%B0%ED%95%98%EC%97%AC-%EA%B0%81-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C\" aria-label=\"어떤 장치가 연산하여 각 렌더링 프로세스를 수행하는 것일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떤 장치가 연산하여 각 렌더링 프로세스를 수행하는 것일까?</h2>\n<p>위 크롬 부라우저 Render Path에서 scirpt가 들어오면 <strong>CPU</strong>에서 <strong>1번, 2번, 3번, 4번</strong>이 이루어진다.<br>\n그 결과를 <strong>Main Memory</strong>에 전달하고 저장하게 된다.<br>\n이것을 <strong>Video Memory</strong>에 전달하면서 <strong>5번</strong>이 이루어진다.<br>\n마지막으로 <strong>GPU</strong>에서 <strong>6번</strong>과정을 거치면서 화면에 출력이 된다.</p>\n<ul>\n<li>필연적으로 <strong>1번, 4번, 6번</strong>는 꼭 발생한다.</li>\n<li><strong>4번과 6번</strong>의 비용은 Layout과 Paint, 그리고 Layer에 결정되어 진다.</li>\n</ul>\n<h1 id=\"브라우저-렌더링-최적화\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"브라우저 렌더링 최적화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 렌더링 최적화</h1>\n<p>브라우저 렌더링을 최적화 하기 위해서는 <code class=\"language-text\">Layout, Paint를 줄이고, 최적의 Layer를 구성하면 된다.</code></p>\n<h2 id=\"layout-paint-비용-줄이기\" style=\"position:relative;\"><a href=\"#layout-paint-%EB%B9%84%EC%9A%A9-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-label=\"layout paint 비용 줄이기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layout, Paint 비용 줄이기</h2>\n<p>Layout, paint를 유발하는 속성을 사용하지 않는다.<br>\nreflow, repaint가 발생하는 속성 알아보기 => <a href=\"https://boxfoxs.tistory.com/408\">https://boxfoxs.tistory.com/408</a></p>\n<p>대신, GPU가 처리할 수 있는 변형을 이용하여 같은 효과를 구현한다.<br>\n왜? GPU가 연산 비용이 훨씬 적기 때문에</p>\n<ul>\n<li>ex) left/top에 의한 이동은 transform: translate를 이용, show/hide는 alpha 값을 이용하는 opacity를 이용<br>\ntransform은 position과 다르게 layer를 새롭게 생성하기 때문에 그 결과 다른 layer에서 렌더링 후 composite하게 되므로 렌더링 성능이 개선된다.(싱글 스레드가 마치 멀티 스레드로 동작하는 것과 흡사)</li>\n</ul>\n<h2 id=\"최적의-layer-구성하기\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81%EC%9D%98-layer-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"최적의 layer 구성하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적의 Layer 구성하기</h2>\n<p>대상 DOM 노드가 주변이나 자신에 의해 자주 변경되지 않는 경우(transform, opacity 제외)로 구성\nex) 사용하지 않는 Layer는 display: none처리하기</p>\n<h2 id=\"참고-문서\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EB%AC%B8%EC%84%9C\" aria-label=\"참고 문서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 문서</h2>\n<ul>\n<li><a href=\"https://sculove.github.io/slides/improveBrowserRendering/#/7\">https://sculove.github.io/slides/improveBrowserRendering/#/7</a></li>\n<li><a href=\"https://web.dev/rendering-performance/\">https://web.dev/rendering-performance/</a></li>\n</ul>","frontmatter":{"date":"October 17, 2022","title":"브라우저 렌더링 최적화","categories":"CS공부","author":"Steadystudy","emoji":"🔥"},"fields":{"slug":"/CS공부/브라우저 렌더링 최적화/"}},"site":{"siteMetadata":{"siteUrl":"https://steadystudy.github.io","comments":{"utterances":{"repo":"Steadystudy/Steadystudy.github.io"}}}}},"pageContext":{"slug":"/CS공부/브라우저 렌더링/","nextSlug":"","prevSlug":"/CS공부/브라우저 렌더링 최적화/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}