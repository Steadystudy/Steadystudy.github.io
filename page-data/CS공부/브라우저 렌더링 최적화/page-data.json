{"componentChunkName":"component---src-templates-blog-template-js","path":"/CS공부/브라우저 렌더링 최적화/","result":{"data":{"cur":{"id":"e3300426-b6c0-50e5-99d1-f235a5f7c459","html":"<h1 id=\"왜-브라우저-렌더링-최적화를-해야하는가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"왜 브라우저 렌더링 최적화를 해야하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 브라우저 렌더링 최적화를 해야하는가?</h1>\n<p>오늘날의 웹 사용자는 페이지가 빠르게 로드되고 잘 실행될 것을 기대한다.<br>\n성능이 뛰어난 사이트와 앱을 만드려면 브라우저에서 HTML, JavaScript 및 CSS를 처리하는 방법을 이해해야 한다.</p>\n<h3 id=\"fpsframe-per-second\" style=\"position:relative;\"><a href=\"#fpsframe-per-second\" aria-label=\"fpsframe per second permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FPS(Frame Per Second)</h3>\n<p>fps는 1초에 몇 프레임이 그려지는지 표현하는 단위이다.<br>\n60fps는 1초에 60장의 프레임이 그려지는 것이다.<br>\n1/60(second) = <strong>16.66ms</strong>안에 새로운 화면을 브라우저가 렌더링을 성공하지 못한다면 애니메이션이 끊김 현상이 발생한다.<br>\n그러나 실제로 브라우저는 하우스키핑 작업을 수행해야 하므로 모든 작업을 <strong>10ms</strong> 이내에 완료해야 한다.</p>\n<h1 id=\"pixel-pipeline\" style=\"position:relative;\"><a href=\"#pixel-pipeline\" aria-label=\"pixel pipeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pixel Pipeline</h1>\n<p><code class=\"language-text\">JS/CSS > Style > Layout > Paint > Composite</code></p>\n<ul>\n<li>Layout: 브라우저에 구성 요소를 배치하는 작업이다. 웹의 레이아웃 모델은 한 요소가 다른 요소에 영향을 줄 수 있다.</li>\n<li>Paint: 픽셀을 채우는 과정이다. 기본적으로 구성 요소의 모든 시각적 부분인 텍스트, 색상, 이미지 등을 그리는 작업이다.</li>\n<li>Composite: 화면에 표시하기 위해 페이지에서 paint 된 부분을 합치는 과정이다.</li>\n</ul>\n<h1 id=\"크롬-브라우저-rendering-path\" style=\"position:relative;\"><a href=\"#%ED%81%AC%EB%A1%AC-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-rendering-path\" aria-label=\"크롬 브라우저 rendering path permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>크롬 브라우저 Rendering Path</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">document.getElementById(\"box\").style.height = \"100px\";</code></pre></div>\n<ol>\n<li><strong>recalculate style</strong>: 엘리먼트에 style을 적용하기 위해 계산하는 작업 (엘리먼트의 style객체가 변경될 떄 발생함)</li>\n<li>height 속성 변경으로 좌표 계산이 필요한가?</li>\n<li>계산이 필요하다면 <strong>Layout</strong> 발생: 언제 발생? width, height, left, top, scroll 등이 변경될 때 발생함.</li>\n<li>효과적인 처리를 위해 <strong>Update Layer Tree</strong>: Layout을 위해, Render Tree를 <strong>변경</strong>하고, paint를 위해 텍스쳐를 <strong>예약</strong>하는 작업</li>\n<li>계산된 영역의 정보를 비트맵으로 저장하기 위해 <strong>paint</strong> 발생: Layer에 엘리먼트의 픽셀 정보를 기록하는 작업</li>\n<li>Composite Layer 작업에서 각 <strong>레이어</strong>를 병합 후, 화면 출력: Layer를 변형하여 화면에 그리는 작업</li>\n</ol>\n<p><code class=\"language-text\">부드러운 애니메이션을 위해서는 위 작업이 모두 10ms 내에 처리되어야 한다.</code></p>\n<p><strong>Layer model</strong>: 웹 페이지를 렌더링하기 위해 필요한 이미지 단위 요소</p>\n<ul>\n<li>레이어들을 배치/합성하여 최종적인 웹페이지를 표현한다.</li>\n<li>모든 페이지는 root 레이어를 가진다.</li>\n<li>레이어의 이미지는 텍스처로서 paint 작업시, CPU에 의해 Video Memory에 로드된다. 따라서, 레이어 생성 비용이 크고, 추가 Memory가 필요하다.</li>\n</ul>\n<h2 id=\"어떤-장치가-연산하여-각-렌더링-프로세스를-수행하는-것일까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A4-%EC%9E%A5%EC%B9%98%EA%B0%80-%EC%97%B0%EC%82%B0%ED%95%98%EC%97%AC-%EA%B0%81-%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C\" aria-label=\"어떤 장치가 연산하여 각 렌더링 프로세스를 수행하는 것일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떤 장치가 연산하여 각 렌더링 프로세스를 수행하는 것일까?</h2>\n<p>위 크롬 부라우저 Render Path에서 scirpt가 들어오면 <strong>CPU</strong>에서 <strong>1번, 2번, 3번, 4번</strong>이 이루어진다.<br>\n그 결과를 <strong>Main Memory</strong>에 전달하고 저장하게 된다.<br>\n이것을 <strong>Video Memory</strong>에 전달하면서 <strong>5번</strong>이 이루어진다.<br>\n마지막으로 <strong>GPU</strong>에서 <strong>6번</strong>과정을 거치면서 화면에 출력이 된다.</p>\n<ul>\n<li>필연적으로 <strong>1번, 4번, 6번</strong>는 꼭 발생한다.</li>\n<li><strong>4번과 6번</strong>의 비용은 Layout과 Paint, 그리고 Layer에 결정되어 진다.</li>\n</ul>\n<h1 id=\"브라우저-렌더링-최적화\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"브라우저 렌더링 최적화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 렌더링 최적화</h1>\n<p>브라우저 렌더링을 최적화 하기 위해서는 <code class=\"language-text\">Layout, Paint를 줄이고, 최적의 Layer를 구성하면 된다.</code></p>\n<h2 id=\"layout-paint-비용-줄이기\" style=\"position:relative;\"><a href=\"#layout-paint-%EB%B9%84%EC%9A%A9-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-label=\"layout paint 비용 줄이기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layout, Paint 비용 줄이기</h2>\n<p>Layout, paint를 유발하는 속성을 사용하지 않는다.<br>\nreflow, repaint가 발생하는 속성 알아보기 => <a href=\"https://boxfoxs.tistory.com/408\">https://boxfoxs.tistory.com/408</a></p>\n<p>대신, GPU가 처리할 수 있는 변형을 이용하여 같은 효과를 구현한다.<br>\n왜? GPU가 연산 비용이 훨씬 적기 때문에</p>\n<ul>\n<li>ex) left/top에 의한 이동은 transform: translate를 이용, show/hide는 alpha 값을 이용하는 opacity를 이용<br>\ntransform은 position과 다르게 layer를 새롭게 생성하기 때문에 그 결과 다른 layer에서 렌더링 후 composite하게 되므로 렌더링 성능이 개선된다.(싱글 스레드가 마치 멀티 스레드로 동작하는 것과 흡사)</li>\n</ul>\n<h2 id=\"최적의-layer-구성하기\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81%EC%9D%98-layer-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"최적의 layer 구성하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적의 Layer 구성하기</h2>\n<p>대상 DOM 노드가 주변이나 자신에 의해 자주 변경되지 않는 경우(transform, opacity 제외)로 구성\nex) 사용하지 않는 Layer는 display: none처리하기</p>\n<h2 id=\"참고-문서\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EB%AC%B8%EC%84%9C\" aria-label=\"참고 문서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 문서</h2>\n<ul>\n<li><a href=\"https://sculove.github.io/slides/improveBrowserRendering/#/7\">https://sculove.github.io/slides/improveBrowserRendering/#/7</a></li>\n<li><a href=\"https://web.dev/rendering-performance/\">https://web.dev/rendering-performance/</a></li>\n</ul>","excerpt":"왜 브라우저 렌더링 최적화를 해야하는가? 오늘날의 웹 사용자는 페이지가 빠르게 로드되고 잘 실행될 것을 기대한다. 성능이 뛰어난 사이트와 앱을 만드려면 브라우저에서 HTML, JavaScript 및 CSS를 처리하는 방법을 이해해야 한다. FPS(Frame Per Second) fps는 1초에 몇 프레임이 그려지는지 표현하는 단위이다. 60fps는 1초에 60장의 프레임이 그려지는 것이다. 1/60(second) = 16.66ms안에 새로운 화면을 브라우저가 렌더링을 성공하지 못한다면 애니메이션이 끊김 현상이 발생한다. 그러나 실제로 브라우저는 하우스키핑 작업을 수행해야 하므로 모든 작업을 10ms 이내에 완료해야 한다. Pixel Pipeline  Layout: 브라우저에 구성 요소를 배치하는 작업이다. 웹의 레이아웃 모델은 한 요소가 다른 요소에 영향을 줄 수 있다. Paint: 픽셀을 채우는 과정이다. 기본적으로 구성 요소의 모든 시각적 부분인 텍스트, 색상, 이미지 등을 그…","frontmatter":{"date":"October 17, 2022","title":"브라우저 렌더링 최적화","categories":"CS공부","author":"Steadystudy","emoji":"🔥"},"fields":{"slug":"/CS공부/브라우저 렌더링 최적화/"}},"next":{"id":"c602ddec-0bea-5709-8288-1f238b3d7fde","html":"<h1 id=\"브라우저-구성요소\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C\" aria-label=\"브라우저 구성요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 구성요소</h1>\n<hr>\n<ul>\n<li>사용자 인터페이스: 주소표시줄, 이전/다음 버튼, 홈버튼, 새로고침 등 요청한 페이지를 보여주는 창 외에 사용자가 컨트롤할 수 있는 부분.</li>\n<li>브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이에 동작을 제어한다. ex) 전달자 역할, 자료 저장소에서 자료를 찾는 역할</li>\n<li>자료 저장소: 쿠키 등의 자료를 컴퓨터 하드디스크에 저장한다. (HTML5부터 Web Database에 저장 가능)</li>\n<li>렌더링 엔진: 요청한 URI를 브라우저 엔진에게 받아서 server에게 요청한다.(통신) server로부터 URI에 해당하는 데이터(HTML, CSS, JavaScript)를 받아서 파싱한 후 렌더링한다.(chrome webkit)</li>\n<li>통신: 렌더링 엔진으로부터 HTTP 요청 등을 받아서 네트워크 처리 후 응답을 전달한다.</li>\n<li>자바스크립트 해석기: Javascript를 파싱한다(chrome V8)</li>\n<li>UI 백엔드: 렌더트리를 브라우저에 그리는 역할을 담당한다.</li>\n</ul>\n<h1 id=\"브라우저-렌더링-과정각-요소의-특징\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EA%B0%81-%EC%9A%94%EC%86%8C%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"브라우저 렌더링 과정각 요소의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 렌더링 과정(각 요소의 특징)</h1>\n<hr>\n<ol>\n<li>사용자가 사용자 인터페이스에 주소표시줄에 URI를 입력하여 브라우저 엔진에 전달한다.</li>\n<li>브라우저 엔진은 자료 저장소에서 URI에 해당하는 자료를 찾고, 해당 자료를 쿠키에 저장했다면 그 자료를 렌더링 엔진에 전달한다.</li>\n<li>렌더링 엔진은 브라우저 엔진에서 가져온 자료를 분석한다. 동시에 URI 데이터를 통신, 자바스크립트 해석기, UI 백엔드로 전파한다.</li>\n<li>또한 렌더링 엔진은 통신 레이어에 URI에 대한 추가 데이터가 있다면 요청하고 응답할 때까지 기다린다.</li>\n<li>응답받은 데이터에서 HTML, CSS는 렌더링 엔진에 파싱한다.</li>\n<li>응답받은 데이터에서 Javascript는 JavaScript 해석기가 파싱한다.</li>\n<li>JavaScript 해석기는 파싱한 결과를 렌더링 엔진에 전달하여 3번과 5번에서 파싱한 HTML의 결과인 DOM tree를 조작한다.</li>\n<li>조작이 완료되면 DOM node(DOM tree 구성요소)는 render object(렌더트리 구성요소)로 변한다.</li>\n<li>UI 백엔드는 render object를 브라우저 렌더링 화면에 띄워준다.</li>\n</ol>\n<h1 id=\"렌더링-엔진\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%94%EC%A7%84\" aria-label=\"렌더링 엔진 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 엔진</h1>\n<hr>\n<p>렌더링 엔진은 URI를 통해 요청을 받아서 해당하는 데이터를 렌더링하는 역할을 담당한다.<br>\nchrome과 IOS는 webkit이라는 렌더링 엔진을 사용한다.</p>\n<h3 id=\"렌더링-엔진-동작-과정\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%97%94%EC%A7%84-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"렌더링 엔진 동작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링 엔진 동작 과정</h3>\n<p><code class=\"language-text\">DOM tree 구축을 위한 HTML 파싱 => 렌더트리 구축 => 렌더트리 배치 => 렌더트리 그리기</code></p>\n<ol>\n<li><code class=\"language-text\">DOM tree 구축</code>을 위한 HTML, CSS, Javscript 파싱: HTML 문서를 파싱한 후, content tree 내부에서 tag를 DOM node로 변환한다.\n그 다은 CSS 파일과 함께 모든 스타일 요소를 파싱한다. 스타일 요소와 HTML 표시 규칙, Javascript의 파싱 결과물은 렌더트리를 생성한다.</li>\n<li><code class=\"language-text\">렌더트리 구축</code>: HTML과 CSS를 파싱해서 만들어진 렌더트리는 색상 또는 면적 등 시각적 속성을 갖는 사각형을 포함한다. 정해진 순서대로 렌더링한다.</li>\n<li><code class=\"language-text\">렌더트리 배치</code>: 렌더트리가 생성이 끝나면, 배치가 시작된다. 각 노트가 정확한 위치에 표시되기 위해 이동한다.</li>\n<li><code class=\"language-text\">렌더트리 그리기</code>: 각 노드 배치를 완료하면 UI 백엔드에서 각 노드를 가로지르며 paint 작업을 한다.</li>\n</ol>\n<p><strong>1번과 2,3,4번은 병렬적으로 진행된다.</strong>\n통신 레이어에서 data를 계속 받아오면서<br>\n받아온 HTML, CSS, JavaScript를 파싱하면서(1번)\n렌더트리에 노드를 그린다.(2,3,4번)</p>\n<h1 id=\"webkit의-동작과정\" style=\"position:relative;\"><a href=\"#webkit%EC%9D%98-%EB%8F%99%EC%9E%91%EA%B3%BC%EC%A0%95\" aria-label=\"webkit의 동작과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>webkit의 동작과정</h1>\n<ol>\n<li>HTML을 파싱하여 DOM 트리를 생성한다.</li>\n</ol>\n<ul>\n<li>왜 HTML을 DOM 트리로 바꾸는가? DOM으로 바꾼 HTML은 JavaScript가 조작할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;html>\n  &lt;body>\n    &lt;span>Hello World&lt;/span>\n    &lt;script>&lt;/script>\n  &lt;/body>\n&lt;/html></code></pre></div>\n<p>브라우저는 tag의 파싱과 실행을 동시에 진행한다.</p>\n<ul>\n<li>왜 <code class=\"language-text\">&lt;script></code>가 body 마지막 줄에 있어야 하나? 앞에 모든 태그들을 파싱한 뒤에 스크립트를 마지막에 파싱하는 동안 추가적으로 파싱할 html태그가 남아있지 않기 때문이다.\n그러므로 HTML5에서 추가된 기능이 있다.</li>\n</ul>\n<ul>\n<li>HTML에서는 <code class=\"language-text\">&lt;script></code> 태그를 비동기로 처리하는 속성을 추가했다.</li>\n</ul>\n<ol start=\"2\">\n<li>CSS를 파싱하여 스타일 규칙을 얻는다.</li>\n<li>DOM 트리를 생성하는 동시에, 이미 생성된 DOM 트리와 스타일 규칙을 Attachment 한다.\n<ul>\n<li>DOM tree를 구성하는 하나의 DOM node는 attach라는 method를 가진다. - 새로운 DOM node가 추가되면 attach가 호출되어 render object를 생성한다.</li>\n<li>render object는 render tree의 구성요소로써, 자신과 자식 요소를 어떻게 배치하고 그려야할지 안다.</li>\n<li>node의 css box를 표시할 정보를 가지고 있다.</li>\n<li>모든 DOM 노드가 전부 render object로 생성되는 것은 아니다. ex) head tag, display none tag 등</li>\n<li><code class=\"language-text\">&lt;html></code>과 <code class=\"language-text\">&lt;body></code> DOM 노드 또한 render object로 구성되는데 이들은 render tree root로써 render view라고 부른다.</li>\n<li>나머지 DOM node들은 render object로 생성되어 이 render tree root에 추가된다.</li>\n</ul>\n</li>\n<li>구축한 렌더 트리를 배치한다.\n배치는 <code class=\"language-text\">&lt;html></code> 요소에 해당하는 최상위 render object에서 시작한다. 화면에 왼쪽 위부터 render object에 해당하는 DOM node를 그려나간다.</li>\n<li>배치가 끝난 렌더 트리를 그린다.</li>\n</ol>\n<h1 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>references</h1>\n<hr>\n<ul>\n<li><a href=\"https://d2.naver.com/helloworld/59361\">https://d2.naver.com/helloworld/59361</a></li>\n<li><a href=\"https://davidhwang.netlify.app/Developments/browser-rendering-process/\">https://davidhwang.netlify.app/Developments/browser-rendering-process/</a></li>\n</ul>","frontmatter":{"date":"October 05, 2022","title":"브라우저 렌더링 과정","categories":"CS공부","author":"Steadystudy","emoji":"🔥"},"fields":{"slug":"/CS공부/브라우저 렌더링/"}},"prev":{"id":"8ba080cb-868d-58d7-8c50-c596ea697f0e","html":"<h1 id=\"jwtjson-web-token\" style=\"position:relative;\"><a href=\"#jwtjson-web-token\" aria-label=\"jwtjson web token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT(JSON Web Token)</h1>\n<p>당사자 간에 정보를 JSON 개체로 안전하게 정보를 전송하기 위한 간결한 token이다.<br>\nJWT는 <strong>인가</strong>에 연관된 기술인데 여기서 <strong>인증</strong>과 <strong>인가</strong>에 대해 간략하게 알아보자.</p>\n<h3 id=\"인증\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EC%A6%9D\" aria-label=\"인증 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인증</h3>\n<p>인증(Authentication)? <strong>(식별가능한 정보로) 서비스에 등록된 유저의 신원을 입증하는 과정</strong><br>\n쉽게 말해서 로그인이라고 생각하면 된다. 즉, 특정 서비스에 일정 권한이 주어진 사용자임을 아이디랑 패스워드 등을 통해서 인증을 받는 것이다.</p>\n<h3 id=\"인가\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EA%B0%80\" aria-label=\"인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인가</h3>\n<p>인가(Authorization)? <strong>자원을 적절한/유효한 사용자에게 전달/공개 하기 위한 방법</strong><br>\n즉 로그인을 하고 나서 내 친구들의 목록을 보거나 글을 작성하는 등 내 계정으로’만’ 할 수 있는 일을 하는 것이다.</p>\n<h3 id=\"jwt는-언제-사용해야-하는가\" style=\"position:relative;\"><a href=\"#jwt%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"jwt는 언제 사용해야 하는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT는 언제 사용해야 하는가?</h3>\n<ul>\n<li>권한 부여: 사용자가 로그인하면 각 후속 요청에는 JWT가 포함되어 사용자가 해당 토큰으로 허용되는 경로, 서비스 및 리소스에 엑세스할 수 있다.</li>\n<li>정보 교환: 서비스가 사용자에게 이 토큰을 통해 공개하기 원하는 내용을 서비스 측에서 원하는 대로 담을 수 있다.\n이렇게 토큰에 담긴 사용자 정보 등의 데이터를 <strong>Claim</strong>이라고 한다.</li>\n</ul>\n<h3 id=\"jwt-웹-토큰-구조\" style=\"position:relative;\"><a href=\"#jwt-%EC%9B%B9-%ED%86%A0%ED%81%B0-%EA%B5%AC%EC%A1%B0\" aria-label=\"jwt 웹 토큰 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 웹 토큰 구조</h3>\n<p>JWT는 ‘XXXX.YYYY.ZZZZ’ 같이 ’.’ 2개를 기준으로 첫 번째는 Header, 두 번째는 Payload, 세 번째는 Signature를 뜻한다.</p>\n<ul>\n<li>Header\n<ul>\n<li>type: 이건 항상 JWT이다.</li>\n<li>alg: 알고리즘의 약자이다. 여러 암호화 방식 중 하나를 지정할 수 있다. ex) ‘HS256’</li>\n<li>JWT의 첫 번째 부분을 형성한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}</code></pre></div>\n<ul>\n<li></li>\n</ul>\n</li>\n<li>Payload\n<ul>\n<li>사용자 정보 및 추가 데이터에 대한 설명 즉,<strong>Claim</strong>을 포함한다.</li>\n<li>payload는 <strong>Base64Url</strong>로 인코딩되어 JWT의 두 번째 부분을 형성한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"sub\": \"123456\",\n  \"name\": \"Steadystudy\",\n  \"admin\": true\n}</code></pre></div>\n</li>\n<li>Signature\n<ul>\n<li>인코딩된 페이로드, 암호, 헤더에 지정된 알고리즘을 가져와서 확인을 해야 한다.</li>\n<li>메시지가 도중에 변경되지 않았는지 확인하는 데 사용되며 개인 키로 서명된 토큰의 경우 JWT의 보낸 사람이 누구인지 확인할 수도 있다.</li>\n</ul>\n</li>\n</ul>\n<p>그래서 혹여 payload를 디코딩하여 조작하면 signature이 달라지기 때문에 payload 내용을 변경해서 악용할 수 없다.</p>\n<h3 id=\"jwt의-장점\" style=\"position:relative;\"><a href=\"#jwt%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"jwt의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT의 장점</h3>\n<ul>\n<li>토큰으로 상태관리를 하기에 따로 세션을 둘 필요가 없다.</li>\n<li>로그인 정보가 사용되는 분야의 확장성이 좋아진다.</li>\n<li>서버를 확장하기에 적합한 환경을 제공한다.</li>\n</ul>\n<h3 id=\"jwt의-단점\" style=\"position:relative;\"><a href=\"#jwt%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"jwt의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT의 단점</h3>\n<ul>\n<li>JWT는 스스로 정보를 담고 있는 토큰이므로 탈취당한다면 정보가 알려질 수 있다.</li>\n<li>시간에 따라 상태값이 바뀌지 않는 stateless이므로 한번 만들어지면 제어가 불가능하다.</li>\n<li>토큰의 상태를 관리하는 중앙 인증 관리 시스템이 없기 떄문에 서버에서 통제를 못한다.</li>\n</ul>\n<h3 id=\"jwt로-안전하게-사용하려면\" style=\"position:relative;\"><a href=\"#jwt%EB%A1%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A0%A4%EB%A9%B4\" aria-label=\"jwt로 안전하게 사용하려면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT로 안전하게 사용하려면?</h3>\n<ul>\n<li>access 토큰과 refresh 토큰 총 두개의 토큰을 준다.</li>\n<li>access 토큰은 매번 인가를 받을 때 사용하고 유효기간을 짧게 준다.</li>\n<li>만약 중간에 access 토큰이 탈취 당해도 유효기간이 짧기 떄문에 오래 쓰지 못하게 된다.</li>\n<li>refresh 토큰은 상응 값을 데이터 베이스에 저장한다. 보통 2주의 유효기간을 준다.</li>\n<li>손님은 access 토큰의 수명이 다하면 refresh 토큰을 서버에 보낸다.</li>\n<li>서버는 refresh 토큰 값을 대조해보고 맞다면 새 access 토큰을 발급한다.</li>\n<li>refresh 토큰만 안전하게 관리된다면 refresh 토큰의 유효할 동안은 다시 로그인할 필요가 없다.</li>\n<li>만약 사용자를 강제 로그아웃 시키려면 refresh 토큰을 DB에서 지워버려 토큰 갱신이 안되게 하면 된다.</li>\n</ul>\n<h3 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h3>\n<ul>\n<li><a href=\"https://jwt.io/introduction\">https://jwt.io/introduction</a></li>\n<li><a href=\"https://velopert.com/2350\">https://velopert.com/2350</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=1QiOXWEbqYQ&#x26;ab_channel=%EC%96%84%ED%8C%8D%ED%95%9C%EC%BD%94%EB%94%A9%EC%82%AC%EC%A0%84\">https://www.youtube.com/watch?v=1QiOXWEbqYQ&#x26;ab_channel=%EC%96%84%ED%8C%8D%ED%95%9C%EC%BD%94%EB%94%A9%EC%82%AC%EC%A0%84</a></li>\n</ul>","frontmatter":{"date":"November 09, 2022","title":"JWT(JSON Web Token)","categories":"CS공부","author":"Steadystudy","emoji":"🔥"},"fields":{"slug":"/CS공부/JWT/"}},"site":{"siteMetadata":{"siteUrl":"https://steadystudy.github.io","comments":{"utterances":{"repo":"Steadystudy/Steadystudy.github.io"}}}}},"pageContext":{"slug":"/CS공부/브라우저 렌더링 최적화/","nextSlug":"/CS공부/브라우저 렌더링/","prevSlug":"/CS공부/JWT/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}